// não tem: jalr, lui, auipc

// ===== BEQ =====
inst[0]  = 32'b00000000001000001000000001100011; // beq x1, x2, +4  (x1 != x2, não salta)
inst[4]  = 32'b00000000000100000000000010010011; // addi x1, x0, 1
inst[8]  = 32'b00000000000100000010000100010011; // addi x2, x0, 1
inst[12] = 32'b00000000001000001000000001100011; // beq x1, x2, +4  (x1 == x2, salta)
inst[16] = 32'b00000000000000000000000000000000; // no-op (não deve ser executado se branch ok)

// ===== BNE =====
inst[20] = 32'b00000000001000001001000001100011; // bne x1, x2, +4 (x1 == x2, não salta)
inst[24] = 32'b00000000000100000010000110010011; // addi x2, x0, 2
inst[28] = 32'b00000000001000001001000001100011; // bne x1, x2, +4 (x1 != x2, salta)
inst[32] = 32'b00000000000000000000000000000000; // no-op

// ===== BLT =====
inst[36] = 32'b00000000001000001100000001100011; // blt x1, x2, +4 (x1 > x2, não salta)
inst[40] = 32'b11111111111100000010000110010011; // addi x2, x0, -1
inst[44] = 32'b00000000001000001100000001100011; // blt x1, x2, +4 (x1 < x2, salta)
inst[48] = 32'b00000000000000000000000000000000; // no-op

// ===== BGE =====
inst[52] = 32'b00000000001000001101000001100011; // bge x1, x2, +4 (x1 < x2, não salta)
inst[56] = 32'b00000000001000000010000110010011; // addi x2, x0, 2
inst[60] = 32'b00000000001000001101000001100011; // bge x1, x2, +4 (x1 >= x2, salta)
inst[64] = 32'b00000000000000000000000000000000; // no-op

// ===== BLTU =====
inst[68] = 32'b00000000001000001110000001100011; // bltu x1, x2, +4 (x1 > x2, unsigned, não salta)
inst[72] = 32'b11111111111100000010000110010011; // addi x2, x0, -1
inst[76] = 32'b00000000001000001110000001100011; // bltu x1, x2, +4 (x1 < x2, unsigned, salta)
inst[80] = 32'b00000000000000000000000000000000; // no-op

// ===== BGEU =====
inst[84] = 32'b00000000001000001111000001100011; // bgeu x1, x2, +4 (x1 < x2, unsigned, não salta)
inst[88] = 32'b00000000000100000010000110010011; // addi x2, x0, 1
inst[92] = 32'b00000000001000001111000001100011; // bgeu x1, x2, +4 (x1 >= x2, unsigned, salta)
inst[96] = 32'b00000000000000000000000000000000; // no-op

------------------------------------------------------------------------------------------------------------------

// Instruções RV32I/RV64I em binário (sem jalr, lui, auipc)

inst[0]  = 32'b00000000000000000000000001101111; // jal x0, 0 (salto para si mesmo)
inst[4]  = 32'b00000000010000000000000101101111; // jal x2, 4 (salta para 8)
inst[8]  = 32'b00000000001100000000000010010011; // addi x1, x0, 3
inst[12] = 32'b11111111110100000000000010010011; // addi x1, x0, -3
inst[16] = 32'b00000000000100001000000110110011; // add x3, x1, x1
inst[20] = 32'b01000000000100001000000110110011; // sub x3, x1, x1
inst[24] = 32'b00000000000100001010000110110011; // sll x3, x1, x1
inst[28] = 32'b00000000000100001100000110110011; // slt x3, x1, x1
inst[32] = 32'b00000000000100001110000110110011; // sltu x3, x1, x1
inst[36] = 32'b00000000000100010000000110110011; // xor x3, x1, x1
inst[40] = 32'b00000000000100010100000110110011; // srl x3, x1, x1
inst[44] = 32'b01000000000100010100000110110011; // sra x3, x1, x1
inst[48] = 32'b00000000000100010110000110110011; // or x3, x1, x1
inst[52] = 32'b00000000000100011000000110110011; // and x3, x1, x1

// Load Instructions
inst[56] = 32'b00000000000000000010001000000011; // lb x4, 0(x0)
inst[60] = 32'b00000000000000001010001000000011; // lbu x4, 0(x1)
inst[64] = 32'b00000000000000000100001000000011; // lh x4, 0(x0)
inst[68] = 32'b00000000000000001100001000000011; // lhu x4, 0(x1)
inst[72] = 32'b00000000000000000110001000000011; // lw x4, 0(x0)

// Store Instructions
inst[76] = 32'b00000000010000000000001100100011; // sb x4, 0(x0)
inst[80] = 32'b00000000010000000010001100100011; // sh x4, 0(x0)
inst[84] = 32'b00000000010000000100001100100011; // sw x4, 0(x0)

// Branch Instructions
inst[88] = 32'b00000000000100001000001001100011; // beq x1, x1, +4
inst[92] = 32'b00000000000100001001001001100011; // bne x1, x1, +4
inst[96] = 32'b00000000000100001100001001100011; // blt x1, x1, +4
inst[100]= 32'b00000000000100001101001001100011; // bge x1, x1, +4
inst[104]= 32'b00000000000100001110001001100011; // bltu x1, x1, +4
inst[108]= 32'b00000000000100001111001001100011; // bgeu x1, x1, +4

// RV64I specific (word operations)
inst[112]= 32'b00000000001100000000000110011011; // addiw x3, x0, 3
inst[116]= 32'b00000000000100001100000110111011; // sllw x3, x1, x1
inst[120]= 32'b00000000000100010100000110111011; // srlw x3, x1, x1
inst[124]= 32'b01000000000100010100000110111011; // sraw x3, x1, x1

// Encerramento com jal para loop infinito
inst[128]= 32'b11111111111111111111000011101111; // jal x1, -2 (loop)


-----------------------------------------------------------------
// ========== RV32I Imediatos Lógicos e Comparação ==========
inst[0]  = 32'b00000000010100000010000100010011; // slti x2, x0, 5     -> x2 = 1
inst[4]  = 32'b00000000101000000011000100010011; // sltiu x2, x0, 10    -> x2 = 1
inst[8]  = 32'b00000000011100000000000111010011; // xori x3, x0, 7      -> x3 = 7
inst[12] = 32'b00000000111100000000001011010011; // ori x5, x0, 15      -> x5 = 15
inst[16] = 32'b00000000001100000000001111010011; // andi x7, x0, 3      -> x7 = 3

// ========== RV32I Shifts com Imediato ==========
inst[20] = 32'b00000000000100001001000110010011; // slli x3, x1, 1      -> x3 = x1 << 1
inst[24] = 32'b00000000000100001010000110010011; // srli x3, x1, 1      -> x3 = x1 >> 1 (lógico)
inst[28] = 32'b01000000000100001010000110010011; // srai x3, x1, 1      -> x3 = x1 >> 1 (aritim.)

// ========== RV64I Loads e Stores 64-bit ==========
inst[32] = 32'b00000000010000000010001100000011; // ld x6, 0(x0)        -> carrega 64 bits
inst[36] = 32'b00000000010000000110001100000011; // lwu x6, 0(x0)       -> carrega 32 bits zero-ext
inst[40] = 32'b00000000011000110000001100100011; // sd x6, 0(x7)        -> armazena 64 bits
